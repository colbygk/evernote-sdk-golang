// Autogenerated by Thrift Compiler (0.9.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package edam

import (
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
	"github.com/colbygk/evernote-sdk-golang/edam"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var _ = edam.GoUnusedProtection__
var _ = edam.GoUnusedProtection__

type UserStore interface { //Service:  UserStore
	//<p>
	//The UserStore service is primarily used by EDAM clients to establish
	//authentication via username and password over a trusted connection (e.g.
	//SSL).  A client's first call to this interface should be checkVersion() to
	//ensure that the client's software is up to date.
	//</p>
	//All calls which require an authenticationToken may throw an
	//EDAMUserException for the following reasons:
	// <ul>
	//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
	//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
	//  <li> DATA_REQUIRED "authenticationToken" - token is empty
	//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
	//  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
	//    privileges
	//</ul>

	// This should be the first call made by a client to the EDAM service.  It
	// tells the service what protocol version is used by the client.  The
	// service will then return true if the client is capable of talking to
	// the service, and false if the client's protocol version is incompatible
	// with the service, so the client must upgrade.  If a client receives a
	// false value, it should report the incompatibility to the user and not
	// continue with any more EDAM requests (UserStore or NoteStore).
	//
	// @param clientName
	//   This string provides some information about the client for
	//   tracking/logging on the service.  It should provide information about
	//   the client's software and platform. The structure should be:
	//   application/version; platform/version; [ device/version ]
	//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
	//
	// @param edamVersionMajor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MAJOR
	//   constant for the client.
	//
	// @param edamVersionMinor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MINOR
	//   constant for the client.
	//
	// Parameters:
	//  - ClientName
	//  - EdamVersionMajor
	//  - EdamVersionMinor
	CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error)
	// This provides bootstrap information to the client. Various bootstrap
	// profiles and settings may be used by the client to configure itself.
	//
	// @param locale
	//   The client's current locale, expressed in language[_country]
	//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
	//   language and country codes.
	//
	// @return
	//   The bootstrap information suitable for this client.
	//
	// Parameters:
	//  - Locale
	GetBootstrapInfo(locale string) (r *BootstrapInfo, err error)
	// This is used to check a username and password in order to create a
	// long-lived authentication token that can be used for further actions.
	//
	// This function is not available to most third party applications,
	// which typically authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	// If you believe that your application requires permission to authenticate
	// using username and password instead of OAuth, please contact Evernote
	// developer support by visiting
	// <a href="http://dev.evernote.com">dev.evernote.com</a>.
	//
	// @param username
	//   The username or registered email address of the account to
	//   authenticate against.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (i.e. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param deviceIdentifier
	//   An optional string that uniquely identifies the device from which the
	//   authentication is being performed. This string allows the service to return the
	//   same authentication token when a given application requests authentication
	//   repeatedly from the same device. This may happen when the user logs out of an
	//   application and then logs back in, or when the application is uninstalled
	//   and later reinstalled. If no reliable device identifier can be created,
	//   this value should be omitted. If set, the device identifier must be between
	//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
	//   EDAM_DEVICE_ID_REGEX.
	//
	// @param deviceDescription
	//   A description of the device from which the authentication is being performed.
	//   This field is displayed to the user in a list of authorized applications to
	//   allow them to distinguish between multiple tokens issued to the same client
	//   application on different devices. For example, the Evernote iOS client on
	//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
	//   "Bob's iPad". The device description must be between 1 and
	//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
	//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by
	//   calling application's API key.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
	//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
	//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> AUTH_EXPIRED "password" - user password is expired
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - DeviceIdentifier
	//  - DeviceDescription
	//  - SupportsTwoFactor
	AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Complete the authentication process when a second factor is required. This
	// call is made after a successful call to authenticate or authenticateLongSession
	// when the authenticating user has enabled two-factor authentication.
	//
	// @param authenticationToken An authentication token returned by a previous
	//   call to UserStore.authenticate or UserStore.authenticateLongSession that
	//   could not be completed in a single call because a second factor was required.
	//
	// @param oneTimeCode The one time code entered by the user. This value is delivered
	//   out-of-band, typically via SMS or an authenticator application.
	//
	// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
	//
	// @param deviceDescription See the corresponding parameter in authenticateLongSession.
	//
	// @return
	//   The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by the
	//   calling application's API key. If the initial authentication call was made to
	//   authenticateLongSession, the AuthenticationResult will contain a long-lived
	//   authentication token.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
	//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
	//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
	//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
	//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
	//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
	//      two-factor authentication.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OneTimeCode
	//  - DeviceIdentifier
	//  - DeviceDescription
	CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Revoke an existing long lived authentication token. This can be used to
	// revoke OAuth tokens or tokens created by calling authenticateLongSession,
	// and allows a user to effectively log out of Evernote from the perspective
	// of the application that holds the token. The authentication token that is
	// passed is immediately revoked and may not be used to call any authenticated
	// EDAM function.
	//
	// @param authenticationToken the authentication token to revoke.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
	//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
	//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
	//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
	//     is already revoked.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	RevokeLongSession(authenticationToken string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// This is used to take an existing authentication token that grants access
	// to an individual user account (returned from 'authenticate',
	// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
	// authentication token that may be used to access business notebooks if the user
	// is a member of an Evernote Business account.
	//
	// The resulting authentication token may be used to make NoteStore API calls
	// against the business using the NoteStore URL returned in the result.
	//
	// @param authenticationToken
	//   The authentication token for the user. This may not be a shared authentication
	//   token (returned by NoteStore.authenticateToSharedNotebook or
	//   NoteStore.authenticateToSharedNote) or a business authentication token.
	//
	// @return
	//   The result of the authentication, with the token granting access to the
	//   business in the result's 'authenticationToken' field. The URL that must
	//   be used to access the business account NoteStore will be returned in the
	//   result's 'noteStoreUrl' field.  The 'User' field will
	//   not be set in the result.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
	//        is a shared or business authentication token. </li>
	//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
	//        authentication token is not currently a member of a business. </li>
	//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
	//        member of is not currently in an active status. </li>
	//   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
	//        sign-on before authenticating to the business.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Returns the User corresponding to the provided authentication token,
	// or throws an exception if this token is not valid.
	// The level of detail provided in the returned User structure depends on
	// the access level granted by the token, so a web service client may receive
	// fewer fields than an integrated desktop client.
	//
	// Parameters:
	//  - AuthenticationToken
	GetUser(authenticationToken string) (r *edam.User, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Asks the UserStore about the publicly available location information for
	// a particular username.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	// </ul>
	//
	// Parameters:
	//  - Username
	GetPublicUserInfo(username string) (r *PublicUserInfo, notFoundException *edam.EDAMNotFoundException, systemException *edam.EDAMSystemException, userException *edam.EDAMUserException, err error)
	// <p>Returns the URLs that should be used when sending requests to the service on
	// behalf of the account represented by the provided authenticationToken.</p>
	//
	// <p>This method isn't needed by most clients, who can retreive the correct set of
	// UserUrls from the AuthenticationResult returned from
	// UserStore#authenticateLongSession(). This method is typically only needed to look up
	// the correct URLs for an existing long-lived authentication token.</p>
	//
	// Parameters:
	//  - AuthenticationToken
	GetUserUrls(authenticationToken string) (r *UserUrls, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Invite a user to join an Evernote Business account.
	//
	// Behavior will depend on the auth token. <ol>
	//   <li>
	//     auth token with privileges to manage Evernote Business membership.
	//       "External Provisioning" - The user will receive an email inviting
	//       them to join the business. They do not need to have an existing Evernote
	//       account. If the user has already been invited, a new invitation email
	//       will be sent.
	//   </li>
	//   <li>
	//     business auth token issued to an admin user. Only for first-party clients:
	//       "Approve Invitation" - If there has been a request to invite the email,
	//       approve it. Invited user will receive email with a link to join business.
	//       "Invite User" - If no invitation for the email exists, create an approved
	//       invitation for the email. An email will be sent to the emailAddress with
	//       a link to join the caller's business.
	//   </li>
	//   </li>
	//     business auth token:
	//       "Request Invitation" - If no invitation exists, create a request to
	//       invite the user to the business. These requests do not count towards a
	//       business' max active user limit.
	//   </li>
	// </ol>
	//
	// @param authenticationToken
	//   the authentication token with sufficient privileges to manage Evernote Business
	//   membership or a business auth token.
	//
	// @param emailAddress
	//   the email address of the user to invite to join the Evernote Business account.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
	//   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
	//   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
	//     whose business email address matches the specified email address. </li>
	//   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
	//     user limit. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - EmailAddress
	InviteToBusiness(authenticationToken string, emailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Remove a user from an Evernote Business account. Once removed, the user will no
	// longer be able to access content within the Evernote Business account.
	//
	// <p>The email address of the user to remove from the business must match the email
	// address used to invite a user to join the business via UserStore.inviteToBusiness.
	// This function will only remove users who were invited by external provisioning</p>
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business
	//   membership.
	//
	// @param emailAddress
	//   The email address of the user to remove from the Evernote Business account.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
	//   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
	// </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li> "email" - If there is no user with the specified email address in the
	//     business or that user was not invited via external provisioning. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - EmailAddress
	RemoveFromBusiness(authenticationToken string, emailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error)
	// Update the email address used to uniquely identify an Evernote Business user.
	//
	// This will update the identifier for a user who was previously invited using
	// inviteToBusiness, ensuring that caller and the Evernote service maintain an
	// agreed-upon identifier for a specific user.
	//
	// For example, the following sequence of calls would invite a user to join
	// a business, update their email address, and then remove the user
	// from the business using the updated email address.
	//
	// inviteToBusiness("foo@bar.com")
	// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
	// removeFromBusiness("baz@bar.com")
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business
	//   membership.
	//
	// @param oldEmailAddress
	//   The existing email address used to uniquely identify the user.
	//
	// @param newEmailAddress
	//   The new email address used to uniquely identify the user.
	//
	// @throws EDAMUserException <ul>
	//   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
	//   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
	//   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
	//   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
	//   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
	//   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
	//     the provided new email address.</li>
	//   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
	//     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
	//     updated.</li>
	// </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
	//     in the business.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OldEmailAddress
	//  - NewEmailAddress
	UpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error)
	// Returns a list of active business users in a given business.
	//
	// Clients are required to cache this information and re-fetch no more than once per day
	// or when they encountered a user ID or username that was not known to them.
	//
	// To avoid excessive look ups, clients should also track user IDs and usernames that belong
	// to users who are not in the business, since they will not be included in the result.
	//
	// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
	// listBusinessUsers to find information about this user. If the user is not in the resulting
	// list, the client should track that fact and not re-query the service the next time that it sees
	// this user on a note.
	//
	// @param authenticationToken
	//   A business authentication token returned by authenticateToBusiness or with sufficient
	//   privileges to manage Evernote Business membership.
	//
	// Parameters:
	//  - AuthenticationToken
	ListBusinessUsers(authenticationToken string) (r []*edam.UserProfile, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Returns a list of outstanding invitations to join an Evernote Business account.
	//
	// Only outstanding invitations are returned by this function. Users who have accepted an
	// invitation and joined a business are listed using listBusinessUsers.
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business membership.
	//
	// @param includeRequestedInvitations
	//   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
	//   in the returned list. If false, only invitations with a status of
	//   BusinessInvitationStatus.APPROVED will be included.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - IncludeRequestedInvitations
	ListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (r []*edam.BusinessInvitation, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error)
	// Retrieve the standard account limits for a given service level. This should only be
	// called when necessary, e.g. to determine if a higher level is available should the
	// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
	// not expected to fluctuate frequently.
	//
	// @throws EDAMUserException <ul>
	//   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
	// </ul>
	//
	// Parameters:
	//  - ServiceLevel
	GetAccountLimits(serviceLevel edam.ServiceLevel) (r *edam.AccountLimits, userException *edam.EDAMUserException, err error)
}

//Service:  UserStore
//<p>
//The UserStore service is primarily used by EDAM clients to establish
//authentication via username and password over a trusted connection (e.g.
//SSL).  A client's first call to this interface should be checkVersion() to
//ensure that the client's software is up to date.
//</p>
//All calls which require an authenticationToken may throw an
//EDAMUserException for the following reasons:
// <ul>
//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
//  <li> DATA_REQUIRED "authenticationToken" - token is empty
//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
//  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
//    privileges
//</ul>
type UserStoreClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewUserStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewUserStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// This should be the first call made by a client to the EDAM service.  It
// tells the service what protocol version is used by the client.  The
// service will then return true if the client is capable of talking to
// the service, and false if the client's protocol version is incompatible
// with the service, so the client must upgrade.  If a client receives a
// false value, it should report the incompatibility to the user and not
// continue with any more EDAM requests (UserStore or NoteStore).
//
// @param clientName
//   This string provides some information about the client for
//   tracking/logging on the service.  It should provide information about
//   the client's software and platform. The structure should be:
//   application/version; platform/version; [ device/version ]
//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
//
// @param edamVersionMajor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MAJOR
//   constant for the client.
//
// @param edamVersionMinor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MINOR
//   constant for the client.
//
// Parameters:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
func (p *UserStoreClient) CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error) {
	if err = p.sendCheckVersion(clientName, edamVersionMajor, edamVersionMinor); err != nil {
		return
	}
	return p.recvCheckVersion()
}

func (p *UserStoreClient) sendCheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("checkVersion", thrift.CALL, p.SeqId)
	args1 := NewCheckVersionArgs()
	args1.ClientName = clientName
	args1.EdamVersionMajor = edamVersionMajor
	args1.EdamVersionMinor = edamVersionMinor
	err = args1.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvCheckVersion() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error3 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error4 error
		error4, err = error3.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error4
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result2 := NewCheckVersionResult()
	err = result2.Read(iprot)
	iprot.ReadMessageEnd()
	value = result2.Success
	return
}

// This provides bootstrap information to the client. Various bootstrap
// profiles and settings may be used by the client to configure itself.
//
// @param locale
//   The client's current locale, expressed in language[_country]
//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
//   language and country codes.
//
// @return
//   The bootstrap information suitable for this client.
//
// Parameters:
//  - Locale
func (p *UserStoreClient) GetBootstrapInfo(locale string) (r *BootstrapInfo, err error) {
	if err = p.sendGetBootstrapInfo(locale); err != nil {
		return
	}
	return p.recvGetBootstrapInfo()
}

func (p *UserStoreClient) sendGetBootstrapInfo(locale string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getBootstrapInfo", thrift.CALL, p.SeqId)
	args5 := NewGetBootstrapInfoArgs()
	args5.Locale = locale
	err = args5.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetBootstrapInfo() (value *BootstrapInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result6 := NewGetBootstrapInfoResult()
	err = result6.Read(iprot)
	iprot.ReadMessageEnd()
	value = result6.Success
	return
}

// This is used to check a username and password in order to create a
// long-lived authentication token that can be used for further actions.
//
// This function is not available to most third party applications,
// which typically authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
// If you believe that your application requires permission to authenticate
// using username and password instead of OAuth, please contact Evernote
// developer support by visiting
// <a href="http://dev.evernote.com">dev.evernote.com</a>.
//
// @param username
//   The username or registered email address of the account to
//   authenticate against.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (i.e. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param deviceIdentifier
//   An optional string that uniquely identifies the device from which the
//   authentication is being performed. This string allows the service to return the
//   same authentication token when a given application requests authentication
//   repeatedly from the same device. This may happen when the user logs out of an
//   application and then logs back in, or when the application is uninstalled
//   and later reinstalled. If no reliable device identifier can be created,
//   this value should be omitted. If set, the device identifier must be between
//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
//   EDAM_DEVICE_ID_REGEX.
//
// @param deviceDescription
//   A description of the device from which the authentication is being performed.
//   This field is displayed to the user in a list of authorized applications to
//   allow them to distinguish between multiple tokens issued to the same client
//   application on different devices. For example, the Evernote iOS client on
//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
//   "Bob's iPad". The device description must be between 1 and
//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by
//   calling application's API key.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> AUTH_EXPIRED "password" - user password is expired
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
func (p *UserStoreClient) AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendAuthenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticateLongSession()
}

func (p *UserStoreClient) sendAuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("authenticateLongSession", thrift.CALL, p.SeqId)
	args9 := NewAuthenticateLongSessionArgs()
	args9.Username = username
	args9.Password = password
	args9.ConsumerKey = consumerKey
	args9.ConsumerSecret = consumerSecret
	args9.DeviceIdentifier = deviceIdentifier
	args9.DeviceDescription = deviceDescription
	args9.SupportsTwoFactor = supportsTwoFactor
	err = args9.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvAuthenticateLongSession() (value *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result10 := NewAuthenticateLongSessionResult()
	err = result10.Read(iprot)
	iprot.ReadMessageEnd()
	value = result10.Success
	if result10.UserException != nil {
		userException = result10.UserException
	}
	if result10.SystemException != nil {
		systemException = result10.SystemException
	}
	return
}

// Complete the authentication process when a second factor is required. This
// call is made after a successful call to authenticate or authenticateLongSession
// when the authenticating user has enabled two-factor authentication.
//
// @param authenticationToken An authentication token returned by a previous
//   call to UserStore.authenticate or UserStore.authenticateLongSession that
//   could not be completed in a single call because a second factor was required.
//
// @param oneTimeCode The one time code entered by the user. This value is delivered
//   out-of-band, typically via SMS or an authenticator application.
//
// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
//
// @param deviceDescription See the corresponding parameter in authenticateLongSession.
//
// @return
//   The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by the
//   calling application's API key. If the initial authentication call was made to
//   authenticateLongSession, the AuthenticationResult will contain a long-lived
//   authentication token.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
//      two-factor authentication.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
func (p *UserStoreClient) CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendCompleteTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription); err != nil {
		return
	}
	return p.recvCompleteTwoFactorAuthentication()
}

func (p *UserStoreClient) sendCompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.CALL, p.SeqId)
	args13 := NewCompleteTwoFactorAuthenticationArgs()
	args13.AuthenticationToken = authenticationToken
	args13.OneTimeCode = oneTimeCode
	args13.DeviceIdentifier = deviceIdentifier
	args13.DeviceDescription = deviceDescription
	err = args13.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvCompleteTwoFactorAuthentication() (value *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result14 := NewCompleteTwoFactorAuthenticationResult()
	err = result14.Read(iprot)
	iprot.ReadMessageEnd()
	value = result14.Success
	if result14.UserException != nil {
		userException = result14.UserException
	}
	if result14.SystemException != nil {
		systemException = result14.SystemException
	}
	return
}

// Revoke an existing long lived authentication token. This can be used to
// revoke OAuth tokens or tokens created by calling authenticateLongSession,
// and allows a user to effectively log out of Evernote from the perspective
// of the application that holds the token. The authentication token that is
// passed is immediately revoked and may not be used to call any authenticated
// EDAM function.
//
// @param authenticationToken the authentication token to revoke.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
//     is already revoked.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RevokeLongSession(authenticationToken string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendRevokeLongSession(authenticationToken); err != nil {
		return
	}
	return p.recvRevokeLongSession()
}

func (p *UserStoreClient) sendRevokeLongSession(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("revokeLongSession", thrift.CALL, p.SeqId)
	args17 := NewRevokeLongSessionArgs()
	args17.AuthenticationToken = authenticationToken
	err = args17.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvRevokeLongSession() (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result18 := NewRevokeLongSessionResult()
	err = result18.Read(iprot)
	iprot.ReadMessageEnd()
	if result18.UserException != nil {
		userException = result18.UserException
	}
	if result18.SystemException != nil {
		systemException = result18.SystemException
	}
	return
}

// This is used to take an existing authentication token that grants access
// to an individual user account (returned from 'authenticate',
// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
// authentication token that may be used to access business notebooks if the user
// is a member of an Evernote Business account.
//
// The resulting authentication token may be used to make NoteStore API calls
// against the business using the NoteStore URL returned in the result.
//
// @param authenticationToken
//   The authentication token for the user. This may not be a shared authentication
//   token (returned by NoteStore.authenticateToSharedNotebook or
//   NoteStore.authenticateToSharedNote) or a business authentication token.
//
// @return
//   The result of the authentication, with the token granting access to the
//   business in the result's 'authenticationToken' field. The URL that must
//   be used to access the business account NoteStore will be returned in the
//   result's 'noteStoreUrl' field.  The 'User' field will
//   not be set in the result.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
//        is a shared or business authentication token. </li>
//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
//        authentication token is not currently a member of a business. </li>
//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
//        member of is not currently in an active status. </li>
//   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
//        sign-on before authenticating to the business.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendAuthenticateToBusiness(authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToBusiness()
}

func (p *UserStoreClient) sendAuthenticateToBusiness(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("authenticateToBusiness", thrift.CALL, p.SeqId)
	args21 := NewAuthenticateToBusinessArgs()
	args21.AuthenticationToken = authenticationToken
	err = args21.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvAuthenticateToBusiness() (value *AuthenticationResult, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result22 := NewAuthenticateToBusinessResult()
	err = result22.Read(iprot)
	iprot.ReadMessageEnd()
	value = result22.Success
	if result22.UserException != nil {
		userException = result22.UserException
	}
	if result22.SystemException != nil {
		systemException = result22.SystemException
	}
	return
}

// Returns the User corresponding to the provided authentication token,
// or throws an exception if this token is not valid.
// The level of detail provided in the returned User structure depends on
// the access level granted by the token, so a web service client may receive
// fewer fields than an integrated desktop client.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUser(authenticationToken string) (r *edam.User, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendGetUser(authenticationToken); err != nil {
		return
	}
	return p.recvGetUser()
}

func (p *UserStoreClient) sendGetUser(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getUser", thrift.CALL, p.SeqId)
	args25 := NewGetUserArgs()
	args25.AuthenticationToken = authenticationToken
	err = args25.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetUser() (value *edam.User, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result26 := NewGetUserResult()
	err = result26.Read(iprot)
	iprot.ReadMessageEnd()
	value = result26.Success
	if result26.UserException != nil {
		userException = result26.UserException
	}
	if result26.SystemException != nil {
		systemException = result26.SystemException
	}
	return
}

// Asks the UserStore about the publicly available location information for
// a particular username.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
// </ul>
//
// Parameters:
//  - Username
func (p *UserStoreClient) GetPublicUserInfo(username string) (r *PublicUserInfo, notFoundException *edam.EDAMNotFoundException, systemException *edam.EDAMSystemException, userException *edam.EDAMUserException, err error) {
	if err = p.sendGetPublicUserInfo(username); err != nil {
		return
	}
	return p.recvGetPublicUserInfo()
}

func (p *UserStoreClient) sendGetPublicUserInfo(username string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getPublicUserInfo", thrift.CALL, p.SeqId)
	args29 := NewGetPublicUserInfoArgs()
	args29.Username = username
	err = args29.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetPublicUserInfo() (value *PublicUserInfo, notFoundException *edam.EDAMNotFoundException, systemException *edam.EDAMSystemException, userException *edam.EDAMUserException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result30 := NewGetPublicUserInfoResult()
	err = result30.Read(iprot)
	iprot.ReadMessageEnd()
	value = result30.Success
	if result30.NotFoundException != nil {
		notFoundException = result30.NotFoundException
	}
	if result30.SystemException != nil {
		systemException = result30.SystemException
	}
	if result30.UserException != nil {
		userException = result30.UserException
	}
	return
}

// <p>Returns the URLs that should be used when sending requests to the service on
// behalf of the account represented by the provided authenticationToken.</p>
//
// <p>This method isn't needed by most clients, who can retreive the correct set of
// UserUrls from the AuthenticationResult returned from
// UserStore#authenticateLongSession(). This method is typically only needed to look up
// the correct URLs for an existing long-lived authentication token.</p>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUserUrls(authenticationToken string) (r *UserUrls, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendGetUserUrls(authenticationToken); err != nil {
		return
	}
	return p.recvGetUserUrls()
}

func (p *UserStoreClient) sendGetUserUrls(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getUserUrls", thrift.CALL, p.SeqId)
	args33 := NewGetUserUrlsArgs()
	args33.AuthenticationToken = authenticationToken
	err = args33.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetUserUrls() (value *UserUrls, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result34 := NewGetUserUrlsResult()
	err = result34.Read(iprot)
	iprot.ReadMessageEnd()
	value = result34.Success
	if result34.UserException != nil {
		userException = result34.UserException
	}
	if result34.SystemException != nil {
		systemException = result34.SystemException
	}
	return
}

// Invite a user to join an Evernote Business account.
//
// Behavior will depend on the auth token. <ol>
//   <li>
//     auth token with privileges to manage Evernote Business membership.
//       "External Provisioning" - The user will receive an email inviting
//       them to join the business. They do not need to have an existing Evernote
//       account. If the user has already been invited, a new invitation email
//       will be sent.
//   </li>
//   <li>
//     business auth token issued to an admin user. Only for first-party clients:
//       "Approve Invitation" - If there has been a request to invite the email,
//       approve it. Invited user will receive email with a link to join business.
//       "Invite User" - If no invitation for the email exists, create an approved
//       invitation for the email. An email will be sent to the emailAddress with
//       a link to join the caller's business.
//   </li>
//   </li>
//     business auth token:
//       "Request Invitation" - If no invitation exists, create a request to
//       invite the user to the business. These requests do not count towards a
//       business' max active user limit.
//   </li>
// </ol>
//
// @param authenticationToken
//   the authentication token with sufficient privileges to manage Evernote Business
//   membership or a business auth token.
//
// @param emailAddress
//   the email address of the user to invite to join the Evernote Business account.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
//   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
//     whose business email address matches the specified email address. </li>
//   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
//     user limit. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) InviteToBusiness(authenticationToken string, emailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendInviteToBusiness(authenticationToken, emailAddress); err != nil {
		return
	}
	return p.recvInviteToBusiness()
}

func (p *UserStoreClient) sendInviteToBusiness(authenticationToken string, emailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("inviteToBusiness", thrift.CALL, p.SeqId)
	args37 := NewInviteToBusinessArgs()
	args37.AuthenticationToken = authenticationToken
	args37.EmailAddress = emailAddress
	err = args37.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvInviteToBusiness() (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result38 := NewInviteToBusinessResult()
	err = result38.Read(iprot)
	iprot.ReadMessageEnd()
	if result38.UserException != nil {
		userException = result38.UserException
	}
	if result38.SystemException != nil {
		systemException = result38.SystemException
	}
	return
}

// Remove a user from an Evernote Business account. Once removed, the user will no
// longer be able to access content within the Evernote Business account.
//
// <p>The email address of the user to remove from the business must match the email
// address used to invite a user to join the business via UserStore.inviteToBusiness.
// This function will only remove users who were invited by external provisioning</p>
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
//
// @param emailAddress
//   The email address of the user to remove from the Evernote Business account.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li> "email" - If there is no user with the specified email address in the
//     business or that user was not invited via external provisioning. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) RemoveFromBusiness(authenticationToken string, emailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error) {
	if err = p.sendRemoveFromBusiness(authenticationToken, emailAddress); err != nil {
		return
	}
	return p.recvRemoveFromBusiness()
}

func (p *UserStoreClient) sendRemoveFromBusiness(authenticationToken string, emailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("removeFromBusiness", thrift.CALL, p.SeqId)
	args41 := NewRemoveFromBusinessArgs()
	args41.AuthenticationToken = authenticationToken
	args41.EmailAddress = emailAddress
	err = args41.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvRemoveFromBusiness() (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result42 := NewRemoveFromBusinessResult()
	err = result42.Read(iprot)
	iprot.ReadMessageEnd()
	if result42.UserException != nil {
		userException = result42.UserException
	}
	if result42.SystemException != nil {
		systemException = result42.SystemException
	}
	if result42.NotFoundException != nil {
		notFoundException = result42.NotFoundException
	}
	return
}

// Update the email address used to uniquely identify an Evernote Business user.
//
// This will update the identifier for a user who was previously invited using
// inviteToBusiness, ensuring that caller and the Evernote service maintain an
// agreed-upon identifier for a specific user.
//
// For example, the following sequence of calls would invite a user to join
// a business, update their email address, and then remove the user
// from the business using the updated email address.
//
// inviteToBusiness("foo@bar.com")
// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
// removeFromBusiness("baz@bar.com")
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
//
// @param oldEmailAddress
//   The existing email address used to uniquely identify the user.
//
// @param newEmailAddress
//   The new email address used to uniquely identify the user.
//
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
//   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
//   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
//   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
//   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
//   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
//     the provided new email address.</li>
//   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
//     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
//     updated.</li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
//     in the business.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OldEmailAddress
//  - NewEmailAddress
func (p *UserStoreClient) UpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error) {
	if err = p.sendUpdateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress); err != nil {
		return
	}
	return p.recvUpdateBusinessUserIdentifier()
}

func (p *UserStoreClient) sendUpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.CALL, p.SeqId)
	args45 := NewUpdateBusinessUserIdentifierArgs()
	args45.AuthenticationToken = authenticationToken
	args45.OldEmailAddress = oldEmailAddress
	args45.NewEmailAddress = newEmailAddress
	err = args45.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvUpdateBusinessUserIdentifier() (userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, notFoundException *edam.EDAMNotFoundException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result46 := NewUpdateBusinessUserIdentifierResult()
	err = result46.Read(iprot)
	iprot.ReadMessageEnd()
	if result46.UserException != nil {
		userException = result46.UserException
	}
	if result46.SystemException != nil {
		systemException = result46.SystemException
	}
	if result46.NotFoundException != nil {
		notFoundException = result46.NotFoundException
	}
	return
}

// Returns a list of active business users in a given business.
//
// Clients are required to cache this information and re-fetch no more than once per day
// or when they encountered a user ID or username that was not known to them.
//
// To avoid excessive look ups, clients should also track user IDs and usernames that belong
// to users who are not in the business, since they will not be included in the result.
//
// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
// listBusinessUsers to find information about this user. If the user is not in the resulting
// list, the client should track that fact and not re-query the service the next time that it sees
// this user on a note.
//
// @param authenticationToken
//   A business authentication token returned by authenticateToBusiness or with sufficient
//   privileges to manage Evernote Business membership.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) ListBusinessUsers(authenticationToken string) (r []*edam.UserProfile, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendListBusinessUsers(authenticationToken); err != nil {
		return
	}
	return p.recvListBusinessUsers()
}

func (p *UserStoreClient) sendListBusinessUsers(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("listBusinessUsers", thrift.CALL, p.SeqId)
	args49 := NewListBusinessUsersArgs()
	args49.AuthenticationToken = authenticationToken
	err = args49.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvListBusinessUsers() (value []*edam.UserProfile, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result50 := NewListBusinessUsersResult()
	err = result50.Read(iprot)
	iprot.ReadMessageEnd()
	value = result50.Success
	if result50.UserException != nil {
		userException = result50.UserException
	}
	if result50.SystemException != nil {
		systemException = result50.SystemException
	}
	return
}

// Returns a list of outstanding invitations to join an Evernote Business account.
//
// Only outstanding invitations are returned by this function. Users who have accepted an
// invitation and joined a business are listed using listBusinessUsers.
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business membership.
//
// @param includeRequestedInvitations
//   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
//   in the returned list. If false, only invitations with a status of
//   BusinessInvitationStatus.APPROVED will be included.
//
// Parameters:
//  - AuthenticationToken
//  - IncludeRequestedInvitations
func (p *UserStoreClient) ListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (r []*edam.BusinessInvitation, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	if err = p.sendListBusinessInvitations(authenticationToken, includeRequestedInvitations); err != nil {
		return
	}
	return p.recvListBusinessInvitations()
}

func (p *UserStoreClient) sendListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("listBusinessInvitations", thrift.CALL, p.SeqId)
	args53 := NewListBusinessInvitationsArgs()
	args53.AuthenticationToken = authenticationToken
	args53.IncludeRequestedInvitations = includeRequestedInvitations
	err = args53.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvListBusinessInvitations() (value []*edam.BusinessInvitation, userException *edam.EDAMUserException, systemException *edam.EDAMSystemException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result54 := NewListBusinessInvitationsResult()
	err = result54.Read(iprot)
	iprot.ReadMessageEnd()
	value = result54.Success
	if result54.UserException != nil {
		userException = result54.UserException
	}
	if result54.SystemException != nil {
		systemException = result54.SystemException
	}
	return
}

// Retrieve the standard account limits for a given service level. This should only be
// called when necessary, e.g. to determine if a higher level is available should the
// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
// not expected to fluctuate frequently.
//
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
// </ul>
//
// Parameters:
//  - ServiceLevel
func (p *UserStoreClient) GetAccountLimits(serviceLevel edam.ServiceLevel) (r *edam.AccountLimits, userException *edam.EDAMUserException, err error) {
	if err = p.sendGetAccountLimits(serviceLevel); err != nil {
		return
	}
	return p.recvGetAccountLimits()
}

func (p *UserStoreClient) sendGetAccountLimits(serviceLevel edam.ServiceLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("getAccountLimits", thrift.CALL, p.SeqId)
	args57 := NewGetAccountLimitsArgs()
	args57.ServiceLevel = serviceLevel
	err = args57.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *UserStoreClient) recvGetAccountLimits() (value *edam.AccountLimits, userException *edam.EDAMUserException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result58 := NewGetAccountLimitsResult()
	err = result58.Read(iprot)
	iprot.ReadMessageEnd()
	value = result58.Success
	if result58.UserException != nil {
		userException = result58.UserException
	}
	return
}

type UserStoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      UserStore
}

func (p *UserStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *UserStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *UserStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewUserStoreProcessor(handler UserStore) *UserStoreProcessor {

	self61 := &UserStoreProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self61.processorMap["checkVersion"] = &userStoreProcessorCheckVersion{handler: handler}
	self61.processorMap["getBootstrapInfo"] = &userStoreProcessorGetBootstrapInfo{handler: handler}
	self61.processorMap["authenticateLongSession"] = &userStoreProcessorAuthenticateLongSession{handler: handler}
	self61.processorMap["completeTwoFactorAuthentication"] = &userStoreProcessorCompleteTwoFactorAuthentication{handler: handler}
	self61.processorMap["revokeLongSession"] = &userStoreProcessorRevokeLongSession{handler: handler}
	self61.processorMap["authenticateToBusiness"] = &userStoreProcessorAuthenticateToBusiness{handler: handler}
	self61.processorMap["getUser"] = &userStoreProcessorGetUser{handler: handler}
	self61.processorMap["getPublicUserInfo"] = &userStoreProcessorGetPublicUserInfo{handler: handler}
	self61.processorMap["getUserUrls"] = &userStoreProcessorGetUserUrls{handler: handler}
	self61.processorMap["inviteToBusiness"] = &userStoreProcessorInviteToBusiness{handler: handler}
	self61.processorMap["removeFromBusiness"] = &userStoreProcessorRemoveFromBusiness{handler: handler}
	self61.processorMap["updateBusinessUserIdentifier"] = &userStoreProcessorUpdateBusinessUserIdentifier{handler: handler}
	self61.processorMap["listBusinessUsers"] = &userStoreProcessorListBusinessUsers{handler: handler}
	self61.processorMap["listBusinessInvitations"] = &userStoreProcessorListBusinessInvitations{handler: handler}
	self61.processorMap["getAccountLimits"] = &userStoreProcessorGetAccountLimits{handler: handler}
	return self61
}

func (p *UserStoreProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x62 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x62.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x62

}

type userStoreProcessorCheckVersion struct {
	handler UserStore
}

func (p *userStoreProcessorCheckVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCheckVersionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCheckVersionResult()
	if result.Success, err = p.handler.CheckVersion(args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkVersion: "+err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("checkVersion", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetBootstrapInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetBootstrapInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetBootstrapInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetBootstrapInfoResult()
	if result.Success, err = p.handler.GetBootstrapInfo(args.Locale); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBootstrapInfo: "+err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getBootstrapInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAuthenticateLongSessionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAuthenticateLongSessionResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.AuthenticateLongSession(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateLongSession: "+err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("authenticateLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorCompleteTwoFactorAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorCompleteTwoFactorAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewCompleteTwoFactorAuthenticationArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewCompleteTwoFactorAuthenticationResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.CompleteTwoFactorAuthentication(args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeTwoFactorAuthentication: "+err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRevokeLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorRevokeLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRevokeLongSessionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRevokeLongSessionResult()
	if result.UserException, result.SystemException, err = p.handler.RevokeLongSession(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing revokeLongSession: "+err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("revokeLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAuthenticateToBusinessArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAuthenticateToBusinessResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.AuthenticateToBusiness(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToBusiness: "+err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("authenticateToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUser struct {
	handler UserStore
}

func (p *userStoreProcessorGetUser) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetUserArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetUserResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetUser(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUser: "+err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getUser", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPublicUserInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPublicUserInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetPublicUserInfoArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetPublicUserInfoResult()
	if result.Success, result.NotFoundException, result.SystemException, result.UserException, err = p.handler.GetPublicUserInfo(args.Username); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicUserInfo: "+err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getPublicUserInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUserUrls struct {
	handler UserStore
}

func (p *userStoreProcessorGetUserUrls) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetUserUrlsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUserUrls", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetUserUrlsResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.GetUserUrls(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUserUrls: "+err.Error())
		oprot.WriteMessageBegin("getUserUrls", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getUserUrls", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorInviteToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorInviteToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewInviteToBusinessArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("inviteToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewInviteToBusinessResult()
	if result.UserException, result.SystemException, err = p.handler.InviteToBusiness(args.AuthenticationToken, args.EmailAddress); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing inviteToBusiness: "+err.Error())
		oprot.WriteMessageBegin("inviteToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("inviteToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRemoveFromBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorRemoveFromBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRemoveFromBusinessArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("removeFromBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRemoveFromBusinessResult()
	if result.UserException, result.SystemException, result.NotFoundException, err = p.handler.RemoveFromBusiness(args.AuthenticationToken, args.EmailAddress); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing removeFromBusiness: "+err.Error())
		oprot.WriteMessageBegin("removeFromBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("removeFromBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorUpdateBusinessUserIdentifier struct {
	handler UserStore
}

func (p *userStoreProcessorUpdateBusinessUserIdentifier) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewUpdateBusinessUserIdentifierArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewUpdateBusinessUserIdentifierResult()
	if result.UserException, result.SystemException, result.NotFoundException, err = p.handler.UpdateBusinessUserIdentifier(args.AuthenticationToken, args.OldEmailAddress, args.NewEmailAddress); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateBusinessUserIdentifier: "+err.Error())
		oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorListBusinessUsers struct {
	handler UserStore
}

func (p *userStoreProcessorListBusinessUsers) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewListBusinessUsersArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listBusinessUsers", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewListBusinessUsersResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.ListBusinessUsers(args.AuthenticationToken); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessUsers: "+err.Error())
		oprot.WriteMessageBegin("listBusinessUsers", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("listBusinessUsers", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorListBusinessInvitations struct {
	handler UserStore
}

func (p *userStoreProcessorListBusinessInvitations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewListBusinessInvitationsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listBusinessInvitations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewListBusinessInvitationsResult()
	if result.Success, result.UserException, result.SystemException, err = p.handler.ListBusinessInvitations(args.AuthenticationToken, args.IncludeRequestedInvitations); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessInvitations: "+err.Error())
		oprot.WriteMessageBegin("listBusinessInvitations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("listBusinessInvitations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetAccountLimits struct {
	handler UserStore
}

func (p *userStoreProcessorGetAccountLimits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetAccountLimitsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getAccountLimits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetAccountLimitsResult()
	if result.Success, result.UserException, err = p.handler.GetAccountLimits(args.ServiceLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAccountLimits: "+err.Error())
		oprot.WriteMessageBegin("getAccountLimits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("getAccountLimits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type CheckVersionArgs struct {
	ClientName       string `thrift:"clientName,1"`
	EdamVersionMajor int16  `thrift:"edamVersionMajor,2"`
	EdamVersionMinor int16  `thrift:"edamVersionMinor,3"`
}

func NewCheckVersionArgs() *CheckVersionArgs {
	return &CheckVersionArgs{
		EdamVersionMajor: 1,

		EdamVersionMinor: 28,
	}
}

func (p *CheckVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ClientName = v
	}
	return nil
}

func (p *CheckVersionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EdamVersionMajor = v
	}
	return nil
}

func (p *CheckVersionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.EdamVersionMinor = v
	}
	return nil
}

func (p *CheckVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("clientName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:clientName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ClientName)); err != nil {
		return fmt.Errorf("%T.clientName (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:clientName: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMajor", thrift.I16, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:edamVersionMajor: %s", p, err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMajor)); err != nil {
		return fmt.Errorf("%T.edamVersionMajor (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:edamVersionMajor: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMinor", thrift.I16, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:edamVersionMinor: %s", p, err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMinor)); err != nil {
		return fmt.Errorf("%T.edamVersionMinor (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:edamVersionMinor: %s", p, err)
	}
	return err
}

func (p *CheckVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckVersionArgs(%+v)", *p)
}

type CheckVersionResult struct {
	Success bool `thrift:"success,0"`
}

func NewCheckVersionResult() *CheckVersionResult {
	return &CheckVersionResult{}
}

func (p *CheckVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *CheckVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *CheckVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckVersionResult(%+v)", *p)
}

type GetBootstrapInfoArgs struct {
	Locale string `thrift:"locale,1"`
}

func NewGetBootstrapInfoArgs() *GetBootstrapInfoArgs {
	return &GetBootstrapInfoArgs{}
}

func (p *GetBootstrapInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetBootstrapInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Locale = v
	}
	return nil
}

func (p *GetBootstrapInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetBootstrapInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("locale", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:locale: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Locale)); err != nil {
		return fmt.Errorf("%T.locale (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:locale: %s", p, err)
	}
	return err
}

func (p *GetBootstrapInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetBootstrapInfoArgs(%+v)", *p)
}

type GetBootstrapInfoResult struct {
	Success *BootstrapInfo `thrift:"success,0"`
}

func NewGetBootstrapInfoResult() *GetBootstrapInfoResult {
	return &GetBootstrapInfoResult{}
}

func (p *GetBootstrapInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetBootstrapInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewBootstrapInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetBootstrapInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetBootstrapInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetBootstrapInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetBootstrapInfoResult(%+v)", *p)
}

type AuthenticateLongSessionArgs struct {
	Username          string `thrift:"username,1"`
	Password          string `thrift:"password,2"`
	ConsumerKey       string `thrift:"consumerKey,3"`
	ConsumerSecret    string `thrift:"consumerSecret,4"`
	DeviceIdentifier  string `thrift:"deviceIdentifier,5"`
	DeviceDescription string `thrift:"deviceDescription,6"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,7"`
}

func NewAuthenticateLongSessionArgs() *AuthenticateLongSessionArgs {
	return &AuthenticateLongSessionArgs{}
}

func (p *AuthenticateLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.readField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Username = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Password = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) readField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 7: %s")
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:username: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return fmt.Errorf("%T.username (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:username: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:password: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return fmt.Errorf("%T.password (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:password: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consumerKey: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return fmt.Errorf("%T.consumerKey (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consumerKey: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consumerSecret: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return fmt.Errorf("%T.consumerSecret (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consumerSecret: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:deviceIdentifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return fmt.Errorf("%T.deviceIdentifier (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:deviceIdentifier: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:deviceDescription: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return fmt.Errorf("%T.deviceDescription (6) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:deviceDescription: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:supportsTwoFactor: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return fmt.Errorf("%T.supportsTwoFactor (7) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:supportsTwoFactor: %s", p, err)
	}
	return err
}

func (p *AuthenticateLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateLongSessionArgs(%+v)", *p)
}

type AuthenticateLongSessionResult struct {
	Success         *AuthenticationResult     `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewAuthenticateLongSessionResult() *AuthenticateLongSessionResult {
	return &AuthenticateLongSessionResult{}
}

func (p *AuthenticateLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateLongSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateLongSessionResult(%+v)", *p)
}

type CompleteTwoFactorAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	OneTimeCode         string `thrift:"oneTimeCode,2"`
	DeviceIdentifier    string `thrift:"deviceIdentifier,3"`
	DeviceDescription   string `thrift:"deviceDescription,4"`
}

func NewCompleteTwoFactorAuthenticationArgs() *CompleteTwoFactorAuthenticationArgs {
	return &CompleteTwoFactorAuthenticationArgs{}
}

func (p *CompleteTwoFactorAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.OneTimeCode = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oneTimeCode", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:oneTimeCode: %s", p, err)
	}
	if err := oprot.WriteString(string(p.OneTimeCode)); err != nil {
		return fmt.Errorf("%T.oneTimeCode (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:oneTimeCode: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:deviceIdentifier: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return fmt.Errorf("%T.deviceIdentifier (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:deviceIdentifier: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:deviceDescription: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return fmt.Errorf("%T.deviceDescription (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:deviceDescription: %s", p, err)
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompleteTwoFactorAuthenticationArgs(%+v)", *p)
}

type CompleteTwoFactorAuthenticationResult struct {
	Success         *AuthenticationResult     `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewCompleteTwoFactorAuthenticationResult() *CompleteTwoFactorAuthenticationResult {
	return &CompleteTwoFactorAuthenticationResult{}
}

func (p *CompleteTwoFactorAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CompleteTwoFactorAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *CompleteTwoFactorAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompleteTwoFactorAuthenticationResult(%+v)", *p)
}

type RevokeLongSessionArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewRevokeLongSessionArgs() *RevokeLongSessionArgs {
	return &RevokeLongSessionArgs{}
}

func (p *RevokeLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RevokeLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *RevokeLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RevokeLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *RevokeLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RevokeLongSessionArgs(%+v)", *p)
}

type RevokeLongSessionResult struct {
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewRevokeLongSessionResult() *RevokeLongSessionResult {
	return &RevokeLongSessionResult{}
}

func (p *RevokeLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RevokeLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *RevokeLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *RevokeLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RevokeLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *RevokeLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *RevokeLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RevokeLongSessionResult(%+v)", *p)
}

type AuthenticateToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewAuthenticateToBusinessArgs() *AuthenticateToBusinessArgs {
	return &AuthenticateToBusinessArgs{}
}

func (p *AuthenticateToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *AuthenticateToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToBusinessArgs(%+v)", *p)
}

type AuthenticateToBusinessResult struct {
	Success         *AuthenticationResult     `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewAuthenticateToBusinessResult() *AuthenticateToBusinessResult {
	return &AuthenticateToBusinessResult{}
}

func (p *AuthenticateToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewAuthenticationResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticateToBusinessResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticateToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticateToBusinessResult(%+v)", *p)
}

type GetUserArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetUserArgs() *GetUserArgs {
	return &GetUserArgs{}
}

func (p *GetUserArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetUserArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetUserArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserArgs(%+v)", *p)
}

type GetUserResult struct {
	Success         *edam.User                `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetUserResult() *GetUserResult {
	return &GetUserResult{}
}

func (p *GetUserResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserResult) readField0(iprot thrift.TProtocol) error {
	p.Success = edam.NewUser()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetUserResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetUserResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetUserResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserResult(%+v)", *p)
}

type GetPublicUserInfoArgs struct {
	Username string `thrift:"username,1"`
}

func NewGetPublicUserInfoArgs() *GetPublicUserInfoArgs {
	return &GetPublicUserInfoArgs{}
}

func (p *GetPublicUserInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicUserInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Username = v
	}
	return nil
}

func (p *GetPublicUserInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicUserInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:username: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return fmt.Errorf("%T.username (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:username: %s", p, err)
	}
	return err
}

func (p *GetPublicUserInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicUserInfoArgs(%+v)", *p)
}

type GetPublicUserInfoResult struct {
	Success           *PublicUserInfo             `thrift:"success,0"`
	NotFoundException *edam.EDAMNotFoundException `thrift:"notFoundException,1"`
	SystemException   *edam.EDAMSystemException   `thrift:"systemException,2"`
	UserException     *edam.EDAMUserException     `thrift:"userException,3"`
}

func NewGetPublicUserInfoResult() *GetPublicUserInfoResult {
	return &GetPublicUserInfoResult{}
}

func (p *GetPublicUserInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewPublicUserInfo()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField1(iprot thrift.TProtocol) error {
	p.NotFoundException = edam.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) readField3(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetPublicUserInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.UserException != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.NotFoundException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPublicUserInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetPublicUserInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPublicUserInfoResult(%+v)", *p)
}

type GetUserUrlsArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewGetUserUrlsArgs() *GetUserUrlsArgs {
	return &GetUserUrlsArgs{}
}

func (p *GetUserUrlsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserUrlsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *GetUserUrlsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserUrls_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserUrlsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *GetUserUrlsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserUrlsArgs(%+v)", *p)
}

type GetUserUrlsResult struct {
	Success         *UserUrls                 `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewGetUserUrlsResult() *GetUserUrlsResult {
	return &GetUserUrlsResult{}
}

func (p *GetUserUrlsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetUserUrlsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewUserUrls()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetUserUrlsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetUserUrlsResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *GetUserUrlsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserUrls_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetUserUrlsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetUserUrlsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserUrlsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *GetUserUrlsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetUserUrlsResult(%+v)", *p)
}

type InviteToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	EmailAddress        string `thrift:"emailAddress,2"`
}

func NewInviteToBusinessArgs() *InviteToBusinessArgs {
	return &InviteToBusinessArgs{}
}

func (p *InviteToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InviteToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *InviteToBusinessArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EmailAddress = v
	}
	return nil
}

func (p *InviteToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("inviteToBusiness_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InviteToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *InviteToBusinessArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("emailAddress", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:emailAddress: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EmailAddress)); err != nil {
		return fmt.Errorf("%T.emailAddress (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:emailAddress: %s", p, err)
	}
	return err
}

func (p *InviteToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InviteToBusinessArgs(%+v)", *p)
}

type InviteToBusinessResult struct {
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewInviteToBusinessResult() *InviteToBusinessResult {
	return &InviteToBusinessResult{}
}

func (p *InviteToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InviteToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *InviteToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *InviteToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("inviteToBusiness_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InviteToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *InviteToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *InviteToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InviteToBusinessResult(%+v)", *p)
}

type RemoveFromBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	EmailAddress        string `thrift:"emailAddress,2"`
}

func NewRemoveFromBusinessArgs() *RemoveFromBusinessArgs {
	return &RemoveFromBusinessArgs{}
}

func (p *RemoveFromBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveFromBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *RemoveFromBusinessArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EmailAddress = v
	}
	return nil
}

func (p *RemoveFromBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("removeFromBusiness_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveFromBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *RemoveFromBusinessArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("emailAddress", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:emailAddress: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EmailAddress)); err != nil {
		return fmt.Errorf("%T.emailAddress (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:emailAddress: %s", p, err)
	}
	return err
}

func (p *RemoveFromBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveFromBusinessArgs(%+v)", *p)
}

type RemoveFromBusinessResult struct {
	UserException     *edam.EDAMUserException     `thrift:"userException,1"`
	SystemException   *edam.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *edam.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewRemoveFromBusinessResult() *RemoveFromBusinessResult {
	return &RemoveFromBusinessResult{}
}

func (p *RemoveFromBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveFromBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *RemoveFromBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *RemoveFromBusinessResult) readField3(iprot thrift.TProtocol) error {
	p.NotFoundException = edam.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *RemoveFromBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("removeFromBusiness_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveFromBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *RemoveFromBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *RemoveFromBusinessResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *RemoveFromBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveFromBusinessResult(%+v)", *p)
}

type UpdateBusinessUserIdentifierArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
	OldEmailAddress     string `thrift:"oldEmailAddress,2"`
	NewEmailAddress     string `thrift:"newEmailAddress,3"`
}

func NewUpdateBusinessUserIdentifierArgs() *UpdateBusinessUserIdentifierArgs {
	return &UpdateBusinessUserIdentifierArgs{}
}

func (p *UpdateBusinessUserIdentifierArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.OldEmailAddress = v
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.NewEmailAddress = v
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateBusinessUserIdentifier_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *UpdateBusinessUserIdentifierArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oldEmailAddress", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:oldEmailAddress: %s", p, err)
	}
	if err := oprot.WriteString(string(p.OldEmailAddress)); err != nil {
		return fmt.Errorf("%T.oldEmailAddress (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:oldEmailAddress: %s", p, err)
	}
	return err
}

func (p *UpdateBusinessUserIdentifierArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("newEmailAddress", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:newEmailAddress: %s", p, err)
	}
	if err := oprot.WriteString(string(p.NewEmailAddress)); err != nil {
		return fmt.Errorf("%T.newEmailAddress (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:newEmailAddress: %s", p, err)
	}
	return err
}

func (p *UpdateBusinessUserIdentifierArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateBusinessUserIdentifierArgs(%+v)", *p)
}

type UpdateBusinessUserIdentifierResult struct {
	UserException     *edam.EDAMUserException     `thrift:"userException,1"`
	SystemException   *edam.EDAMSystemException   `thrift:"systemException,2"`
	NotFoundException *edam.EDAMNotFoundException `thrift:"notFoundException,3"`
}

func NewUpdateBusinessUserIdentifierResult() *UpdateBusinessUserIdentifierResult {
	return &UpdateBusinessUserIdentifierResult{}
}

func (p *UpdateBusinessUserIdentifierResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierResult) readField3(iprot thrift.TProtocol) error {
	p.NotFoundException = edam.NewEDAMNotFoundException()
	if err := p.NotFoundException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.NotFoundException)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateBusinessUserIdentifier_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.NotFoundException != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UpdateBusinessUserIdentifierResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateBusinessUserIdentifierResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateBusinessUserIdentifierResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.NotFoundException != nil {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:notFoundException: %s", p, err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.NotFoundException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:notFoundException: %s", p, err)
		}
	}
	return err
}

func (p *UpdateBusinessUserIdentifierResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UpdateBusinessUserIdentifierResult(%+v)", *p)
}

type ListBusinessUsersArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1"`
}

func NewListBusinessUsersArgs() *ListBusinessUsersArgs {
	return &ListBusinessUsersArgs{}
}

func (p *ListBusinessUsersArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListBusinessUsersArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListBusinessUsersArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessUsers_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListBusinessUsersArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListBusinessUsersArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListBusinessUsersArgs(%+v)", *p)
}

type ListBusinessUsersResult struct {
	Success         []*edam.UserProfile       `thrift:"success,0"`
	UserException   *edam.EDAMUserException   `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException `thrift:"systemException,2"`
}

func NewListBusinessUsersResult() *ListBusinessUsersResult {
	return &ListBusinessUsersResult{}
}

func (p *ListBusinessUsersResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListBusinessUsersResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*edam.UserProfile, 0, size)
	for i := 0; i < size; i++ {
		_elem63 := edam.NewUserProfile()
		if err := _elem63.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem63)
		}
		p.Success = append(p.Success, _elem63)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListBusinessUsersResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListBusinessUsersResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListBusinessUsersResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessUsers_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListBusinessUsersResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessUsersResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessUsersResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessUsersResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListBusinessUsersResult(%+v)", *p)
}

type ListBusinessInvitationsArgs struct {
	AuthenticationToken         string `thrift:"authenticationToken,1"`
	IncludeRequestedInvitations bool   `thrift:"includeRequestedInvitations,2"`
}

func NewListBusinessInvitationsArgs() *ListBusinessInvitationsArgs {
	return &ListBusinessInvitationsArgs{}
}

func (p *ListBusinessInvitationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListBusinessInvitationsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *ListBusinessInvitationsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.IncludeRequestedInvitations = v
	}
	return nil
}

func (p *ListBusinessInvitationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessInvitations_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListBusinessInvitationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:authenticationToken: %s", p, err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return fmt.Errorf("%T.authenticationToken (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:authenticationToken: %s", p, err)
	}
	return err
}

func (p *ListBusinessInvitationsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeRequestedInvitations", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:includeRequestedInvitations: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IncludeRequestedInvitations)); err != nil {
		return fmt.Errorf("%T.includeRequestedInvitations (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:includeRequestedInvitations: %s", p, err)
	}
	return err
}

func (p *ListBusinessInvitationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListBusinessInvitationsArgs(%+v)", *p)
}

type ListBusinessInvitationsResult struct {
	Success         []*edam.BusinessInvitation `thrift:"success,0"`
	UserException   *edam.EDAMUserException    `thrift:"userException,1"`
	SystemException *edam.EDAMSystemException  `thrift:"systemException,2"`
}

func NewListBusinessInvitationsResult() *ListBusinessInvitationsResult {
	return &ListBusinessInvitationsResult{}
}

func (p *ListBusinessInvitationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ListBusinessInvitationsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*edam.BusinessInvitation, 0, size)
	for i := 0; i < size; i++ {
		_elem64 := edam.NewBusinessInvitation()
		if err := _elem64.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem64)
		}
		p.Success = append(p.Success, _elem64)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ListBusinessInvitationsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *ListBusinessInvitationsResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = edam.NewEDAMSystemException()
	if err := p.SystemException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SystemException)
	}
	return nil
}

func (p *ListBusinessInvitationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessInvitations_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.SystemException != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ListBusinessInvitationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessInvitationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessInvitationsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SystemException != nil {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:systemException: %s", p, err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.SystemException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:systemException: %s", p, err)
		}
	}
	return err
}

func (p *ListBusinessInvitationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ListBusinessInvitationsResult(%+v)", *p)
}

type GetAccountLimitsArgs struct {
	ServiceLevel edam.ServiceLevel `thrift:"serviceLevel,1"`
}

func NewGetAccountLimitsArgs() *GetAccountLimitsArgs {
	return &GetAccountLimitsArgs{
		ServiceLevel: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *GetAccountLimitsArgs) IsSetServiceLevel() bool {
	return int64(p.ServiceLevel) != math.MinInt32-1
}

func (p *GetAccountLimitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAccountLimitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ServiceLevel = edam.ServiceLevel(v)
	}
	return nil
}

func (p *GetAccountLimitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAccountLimits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAccountLimitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetServiceLevel() {
		if err := oprot.WriteFieldBegin("serviceLevel", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:serviceLevel: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ServiceLevel)); err != nil {
			return fmt.Errorf("%T.serviceLevel (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:serviceLevel: %s", p, err)
		}
	}
	return err
}

func (p *GetAccountLimitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAccountLimitsArgs(%+v)", *p)
}

type GetAccountLimitsResult struct {
	Success       *edam.AccountLimits     `thrift:"success,0"`
	UserException *edam.EDAMUserException `thrift:"userException,1"`
}

func NewGetAccountLimitsResult() *GetAccountLimitsResult {
	return &GetAccountLimitsResult{}
}

func (p *GetAccountLimitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error", p)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetAccountLimitsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = edam.NewAccountLimits()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetAccountLimitsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = edam.NewEDAMUserException()
	if err := p.UserException.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.UserException)
	}
	return nil
}

func (p *GetAccountLimitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAccountLimits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.UserException != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetAccountLimitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetAccountLimitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.UserException != nil {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:userException: %s", p, err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.UserException)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:userException: %s", p, err)
		}
	}
	return err
}

func (p *GetAccountLimitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetAccountLimitsResult(%+v)", *p)
}
